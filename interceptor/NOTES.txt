

			contentType := resp.Header["Content-Type"]
			//contentEnc := resp.Header["Content-Encoding"]
			//log.Println("ENCODING:", resp.TransferEncoding, ":", contentEnc, ":", resp.Uncompressed)

			if len(contentType) != 0 {

				reader := resp.Body
				/*
					if len(contentEnc) != 0 {
						if contentEnc[0] == "gzip" {
							r, qerr := gzip.NewReader(resp.Body)
							if qerr != nil {
								log.Println("ERROR GZIP:", qerr)
							}
							reader = r
						}
					}
				*/

				switch contentType[0] {
				// TODO: ASCII, ANSI (Windows-1252)
				case "text/html", "text/html; charset=utf-8", "text/html; charset=UTF-8":
					// Default charset for HTML5
					log.Print("MATCHED:", contentType[0])

					b, err := ioutil.ReadAll(reader)
					if err != nil {
						log.Println(err)
					}
					fmt.Println(string(b))
					/*
						body, perr := html.Parse(resp.Body)
						if perr != nil {
							log.Println("PARSE ERROR:", perr)
							break
						} else {
							doc := goquery.NewDocumentFromNode(body)
							fmt.Println("DOC:", doc.Find("h1").Text())
						}
					*/
				case "text/html; charset=iso-8859-1", "text/html; charset=ISO-8859-1":
					// Default charset for HTML 2 to 4
					// TODO: Do something with it, e.g. convert with iconv.
					log.Print("MATCHED:", contentType[0])
					fallthrough
				default:
					//log.Println("UNUSED TYPE:", contentTyp
				}
			}
